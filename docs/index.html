<!DOCTYPE html>

<html>
<head>
  <title>index.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>index.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-comment">/**
 * Created by Tom on 01.11.2017.
 */</span>
<span class="hljs-comment">/**
 * @license MIT License

 Copyright (c) 2017 Tom "L3tum" Pauly

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */</span>
<span class="hljs-keyword">import</span> md5 <span class="hljs-keyword">from</span> <span class="hljs-string">"md5"</span>;
<span class="hljs-keyword">import</span> localforage <span class="hljs-keyword">from</span> <span class="hljs-string">"localforage"</span>;
<span class="hljs-keyword">import</span> Config <span class="hljs-keyword">from</span> <span class="hljs-string">"config"</span>;

<span class="hljs-comment">/**
 * The config to use
 */</span>
<span class="hljs-keyword">var</span> config;

<span class="hljs-comment">/**
 * Files queued for updating
 * @type {String[]}
 */</span>
<span class="hljs-keyword">const</span> updateable = [];

<span class="hljs-comment">/**
 * Helper to merge configs
 * @param standard {Config}
 * @param user {Config}
 * @returns {Config}
 */</span>
<span class="hljs-keyword">const</span> merge = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">standard, user</span>) </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> idx <span class="hljs-keyword">in</span> user) {
        <span class="hljs-keyword">if</span> (idx === <span class="hljs-string">"URLS_TO_CACHE_BLACKLIST"</span> || idx === <span class="hljs-string">"UPDATE_BLACKLIST"</span>) {
            standard[idx] = standard[idx].concat(user[idx]);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (idx === <span class="hljs-string">"METHODS"</span>) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> user[<span class="hljs-string">"METHODS"</span>]) {
                <span class="hljs-keyword">if</span> (user[<span class="hljs-string">"METHODS"</span>].hasOwnProperty(key)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>eslint-disable-next-line no-new-func</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    callbacks[key] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(user[<span class="hljs-string">"METHODS"</span>][key]);
                }
            }
        } <span class="hljs-keyword">else</span> {
            standard[idx] = user[idx];
        }
    }
    <span class="hljs-keyword">return</span> standard;
};

<span class="hljs-comment">/**
 * Converts a byte array to a string
 * @param array {number}
 * @returns {*}
 */</span>
<span class="hljs-keyword">const</span> bin2String = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">array</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">String</span>.fromCharCode.apply(<span class="hljs-built_in">String</span>, array);
};

<span class="hljs-comment">/**
 * Hashes a file given its blob
 * @param blob {Blob}
 * @returns {Promise.&lt;string&gt;|*}
 */</span>
<span class="hljs-keyword">const</span> md5HashBody = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>{
        <span class="hljs-keyword">let</span> arrayBuffer;
        <span class="hljs-keyword">let</span> fileReader = <span class="hljs-keyword">new</span> FileReader();

        fileReader.onloadend = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            arrayBuffer = <span class="hljs-keyword">this</span>.result;
            bin2String(arrayBuffer).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
                <span class="hljs-keyword">let</span> hash = md5(result);

                resolve(hash);
            });
        };
        fileReader.readAsArrayBuffer(blob);
    });
};

<span class="hljs-comment">/**
 * Checks for a given URL if it is allowed to be cached
 * @param url
 * @returns {Promise&lt;boolean&gt;}
 */</span>
<span class="hljs-keyword">const</span> canBeCached = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
    <span class="hljs-keyword">let</span> whitelisted = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> blacklisted = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> regex <span class="hljs-keyword">of</span> config.URLS_TO_CACHE_WHITELIST) {
        <span class="hljs-keyword">if</span> (url.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regex, <span class="hljs-string">"gi"</span>)) !== <span class="hljs-literal">null</span>) {
            whitelisted = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">if</span> (whitelisted) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> regex <span class="hljs-keyword">of</span> config.URLS_TO_CACHE_BLACKLIST) {
            <span class="hljs-keyword">if</span> (url.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regex, <span class="hljs-string">"gi"</span>)) !== <span class="hljs-literal">null</span>) {
                blacklisted = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> whitelisted &amp;&amp; !blacklisted;
};

<span class="hljs-comment">/**
 * Checks if a given URL is allowed to be updated
 * @param url
 * @returns {Promise&lt;boolean&gt;}
 */</span>
<span class="hljs-keyword">const</span> canBeUpdated = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
    <span class="hljs-keyword">let</span> whitelisted = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> blacklisted = <span class="hljs-literal">false</span>;

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> regex <span class="hljs-keyword">of</span> config.UPDATE_WHITELIST) {
        <span class="hljs-keyword">if</span> (url.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regex, <span class="hljs-string">"gi"</span>)) !== <span class="hljs-literal">null</span>) {
            whitelisted = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">break</span>;
        }
    }
    <span class="hljs-keyword">if</span> (whitelisted) {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> regex <span class="hljs-keyword">of</span> config.UPDATE_BLACKLIST) {
            <span class="hljs-keyword">if</span> (url.match(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(regex, <span class="hljs-string">"gi"</span>)) !== <span class="hljs-literal">null</span>) {
                blacklisted = <span class="hljs-literal">true</span>;
                <span class="hljs-keyword">break</span>;
            }
        }
    }
    <span class="hljs-keyword">return</span> whitelisted &amp;&amp; !blacklisted;
};

<span class="hljs-comment">/**
 * Caches a response given the request/URL
 * @param request {Request|string}
 * @param response {Response}
 */</span>
<span class="hljs-keyword">const</span> cacheResponse = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, response</span>) </span>{
    <span class="hljs-keyword">let</span> url;

    <span class="hljs-keyword">if</span> (request.url) {
        url = request.url;
    } <span class="hljs-keyword">else</span> {
        url = request;
    }
    <span class="hljs-keyword">if</span> (canBeCached(url)) {
        caches.open(config.CACHE_NAME + config.VERSION).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cache</span>) </span>{
            cache.put(url, response);
        });
    }
};

<span class="hljs-comment">/**
 * Fetches a request only if we may be online (since navigator.onLine is funky)
 * @param request {Request|string}
 * @param options {{}}
 * @returns {Promise&lt;Response&gt;|null}
 */</span>
<span class="hljs-keyword">const</span> fetchResponse = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">request, options = null</span>) </span>{
    <span class="hljs-keyword">if</span> (navigator.onLine) {
        <span class="hljs-keyword">if</span> (options !== <span class="hljs-literal">null</span>) {
            <span class="hljs-keyword">return</span> fetch(request, options).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                <span class="hljs-keyword">return</span> response;
            });
        }
        <span class="hljs-keyword">return</span> fetch(request).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
            <span class="hljs-keyword">return</span> response;
        });
    }
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
};

<span class="hljs-keyword">const</span> postMessages = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type, message</span>) </span>{
    self.postMessage({<span class="hljs-attr">type</span>: type, <span class="hljs-attr">message</span>: message});
};

<span class="hljs-keyword">const</span> callbacks = [];

<span class="hljs-comment">/**
 * Provide cache and if not present provide fetch.
 * Does not update automatically
 * @param event {Event}
 * @returns {Promise.&lt;Response&gt;|*}
 */</span>
callbacks[<span class="hljs-string">"cacheFirst"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span>(event</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> clonedReqForNetwork = event.request.clone();

        <span class="hljs-keyword">return</span> caches.match(event.request.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matched</span>) </span>{
            <span class="hljs-comment">/**
             * Check if valid response from cache
             */</span>
            <span class="hljs-keyword">if</span> (matched !== <span class="hljs-literal">null</span> &amp;&amp; matched.type !== <span class="hljs-string">"error"</span>) {
                <span class="hljs-keyword">return</span> matched;
            }
            <span class="hljs-keyword">let</span> clonedReqForCache = clonedReqForNetwork.clone();

            <span class="hljs-keyword">return</span> fetchResponse(clonedReqForNetwork.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                <span class="hljs-comment">/**
                 * Check if cacheable
                 */</span>
                <span class="hljs-keyword">if</span> (networkResponse !== <span class="hljs-literal">null</span> &amp;&amp; networkResponse !== <span class="hljs-string">"error"</span>) {
                    <span class="hljs-comment">/**
                     * Cache response
                     */</span>
                    <span class="hljs-keyword">let</span> clonedRespForCache = networkResponse.clone();

                    cacheResponse(clonedReqForCache, clonedRespForCache);
                }
                <span class="hljs-keyword">return</span> networkResponse;
            });
        }).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">/**
             * Cache did not find anything
             */</span>

            <span class="hljs-keyword">let</span> clonedReqForCache = clonedReqForNetwork.clone();

            <span class="hljs-keyword">return</span> fetchResponse(clonedReqForNetwork.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                <span class="hljs-comment">/**
                 * Check if cacheable
                 */</span>
                <span class="hljs-keyword">if</span> (networkResponse !== <span class="hljs-literal">null</span> &amp;&amp; networkResponse !== <span class="hljs-string">"error"</span>) {
                    <span class="hljs-comment">/**
                     * Cache response
                     */</span>
                    <span class="hljs-keyword">let</span> clonedRespForCache = networkResponse.clone();

                    cacheResponse(clonedReqForCache, clonedRespForCache);
                }
                <span class="hljs-keyword">return</span> networkResponse;
            });
        });
    })(event);
};

<span class="hljs-comment">/**
 * Network first strategy.
 * Since it fetches first-thing it won't need to update
 * @param event
 * @returns {Promise.&lt;Response&gt;|*}
 */</span>
callbacks[<span class="hljs-string">"networkFirst"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span>(event</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> clonedReqForCache = event.request.clone();

        <span class="hljs-keyword">return</span> fetchResponse(event.request.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
            <span class="hljs-keyword">if</span> (networkResponse !== <span class="hljs-literal">null</span> &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                <span class="hljs-keyword">let</span> clonedRespForReturn = networkResponse.clone();

                cacheResponse(clonedReqForCache, networkResponse);
                <span class="hljs-keyword">return</span> clonedRespForReturn;
            }
            <span class="hljs-keyword">return</span> caches.match(event.request.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matched</span>) </span>{
                <span class="hljs-keyword">return</span> matched;
            });
        });
    })(event);
};

<span class="hljs-comment">/**
 * Stale while revalidate strategy.
 * Serve a, potentially, outdated file but then check for updates with a fallback to network
 * @param event
 * @returns {Promise.&lt;Response&gt;|*}
 */</span>
callbacks[<span class="hljs-string">"staleWhileRevalidate"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span>(event</span>) =&gt;</span> {
        <span class="hljs-keyword">let</span> clonedReqForNetwork = event.request.clone();

        <span class="hljs-keyword">return</span> caches.match(event.request.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">matched</span>) </span>{
            <span class="hljs-keyword">if</span> (matched &amp;&amp; matched.type !== <span class="hljs-string">"error"</span>) {
                <span class="hljs-comment">/**
                 * Update
                 */</span>
                updateable.push(event.request.url);
                <span class="hljs-keyword">if</span> (checkUpdateTimeout === <span class="hljs-literal">null</span>) {
                    checkUpdateTimeout = setTimeout(checkUpdate, <span class="hljs-number">500</span>);
                }
                <span class="hljs-keyword">return</span> matched;
            }
            <span class="hljs-keyword">return</span> fetchResponse(event.request.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                <span class="hljs-keyword">if</span> (networkResponse !== <span class="hljs-literal">null</span> &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                    <span class="hljs-keyword">let</span> clonedForCache = networkResponse.clone();

                    cacheResponse(clonedReqForNetwork, clonedForCache);
                }
                <span class="hljs-keyword">return</span> networkResponse;
            });
        }).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">return</span> fetchResponse(event.request.url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                <span class="hljs-keyword">if</span> (networkResponse !== <span class="hljs-literal">null</span> &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                    <span class="hljs-keyword">let</span> clonedForCache = networkResponse.clone();

                    cacheResponse(clonedReqForNetwork, clonedForCache);
                }
                <span class="hljs-keyword">return</span> networkResponse;
            });
        });
    })(event);
};

<span class="hljs-comment">/**
 * Requests a file from the internet and checks if the cached config.VERSION is different
 * @param url {string}
 */</span>
callbacks[<span class="hljs-string">"requestFileUpdate"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span>(url</span>) =&gt;</span> {
        caches.match(url).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cachedInstance</span>) </span>{
            <span class="hljs-comment">/**
             * Is not cached for some reason
             */</span>
            <span class="hljs-keyword">if</span> (!cachedInstance || cachedInstance.type === <span class="hljs-string">"error"</span>) {
                <span class="hljs-keyword">let</span> abort = <span class="hljs-literal">false</span>;

                <span class="hljs-comment">/**
                 * Remove from database to prevent duplicates
                 */</span>
                localforage.removeItem(url);
                <span class="hljs-comment">/**
                 * Fetch file to store in cache
                 */</span>
                <span class="hljs-keyword">await</span> fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                    <span class="hljs-comment">/**
                     * Check for valid response
                     */</span>
                    <span class="hljs-keyword">if</span> (networkResponse &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                        cachedInstance = networkResponse.clone();
                        cacheResponse(url, networkResponse);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">/**
                         * File is something else, just leave it
                         */</span>
                        abort = <span class="hljs-literal">true</span>;
                    }
                });
                <span class="hljs-keyword">if</span> (abort) {
                    <span class="hljs-keyword">return</span>;
                }
            }
            localforage.getItem(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
                <span class="hljs-comment">/**
                 * Doesn't have value yet, hash it and finished
                 */</span>
                <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                    cachedInstance.blob().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                        md5HashBody(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                            localforage.setItem(url, hash);
                        });
                    });
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">/**
                     * Fetch newest file and check for updates
                     */</span>
                    fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                        <span class="hljs-comment">/**
                         * Check if we received valid file
                         */</span>
                        <span class="hljs-keyword">if</span> (networkResponse &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                            <span class="hljs-keyword">let</span> clonedResponse = networkResponse.clone();

                            networkResponse.blob().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                                md5HashBody(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                                    <span class="hljs-comment">/**
                                     * File got updated
                                     */</span>
                                    <span class="hljs-keyword">if</span> (hash !== value) {
                                        cacheResponse(url, clonedResponse);
                                        localforage.setItem(url, hash);
                                        postMessages(<span class="hljs-number">0</span>, {<span class="hljs-attr">file</span>: url});
                                    }
                                });
                            });
                        }
                    });
                }
            });
        }).catch(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">/**
             * Cache did not find file
             */</span>

            <span class="hljs-keyword">let</span> cachedInstance;

            fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                <span class="hljs-comment">/**
                 * Check for valid response
                 */</span>
                <span class="hljs-keyword">if</span> (networkResponse &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                    cachedInstance = networkResponse.clone();
                    cacheResponse(url, networkResponse);

                    localforage.getItem(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
                        <span class="hljs-comment">/**
                         * Doesn't have value yet, hash it and finished
                         */</span>
                        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                            cachedInstance.blob().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                                md5HashBody(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                                    localforage.setItem(url, hash);
                                });
                            });
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-comment">/**
                             * Fetch newest file and check for updates
                             */</span>
                            fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                                <span class="hljs-comment">/**
                                 * Check if we received valid file
                                 */</span>
                                <span class="hljs-keyword">if</span> (networkResponse &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                                    <span class="hljs-keyword">let</span> clonedResponse = networkResponse.clone();

                                    networkResponse.blob().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                                        md5HashBody(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                                            <span class="hljs-comment">/**
                                             * File got updated
                                             */</span>
                                            <span class="hljs-keyword">if</span> (hash !== value) {
                                                cacheResponse(url, clonedResponse);
                                                localforage.setItem(url, hash);
                                                postMessages(<span class="hljs-number">0</span>, {<span class="hljs-attr">file</span>: url});
                                            }
                                        });
                                    });
                                }
                            });
                        }
                    });
                }
            });
        });
    })(url);
};

<span class="hljs-comment">/**
 * Requests the hash of a specific file from a specified URL via POST
 * @param url
 */</span>
callbacks[<span class="hljs-string">"requestServerHash"</span>] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">async</span>(url</span>) =&gt;</span> {
        caches.match(url).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">cachedInstance</span>) </span>{
            <span class="hljs-comment">/**
             * Is not cached for some reason
             */</span>
            <span class="hljs-keyword">if</span> (!cachedInstance || cachedInstance.type === <span class="hljs-string">"error"</span>) {
                <span class="hljs-keyword">let</span> abort = <span class="hljs-literal">false</span>;

                <span class="hljs-comment">/**
                 * Remove from database to prevent duplicates
                 */</span>
                localforage.removeItem(url);
                <span class="hljs-comment">/**
                 * Fetch file to store in cache
                 */</span>
                <span class="hljs-keyword">await</span> fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                    <span class="hljs-comment">/**
                     * Check for valid response
                     */</span>
                    <span class="hljs-keyword">if</span> (networkResponse &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                        cachedInstance = networkResponse.clone();
                        cacheResponse(url, networkResponse);
                    } <span class="hljs-keyword">else</span> {
                        <span class="hljs-comment">/**
                         * File is something else, just leave it
                         */</span>
                        abort = <span class="hljs-literal">true</span>;
                    }
                });
                <span class="hljs-keyword">if</span> (abort) {
                    <span class="hljs-keyword">return</span>;
                }
            }
            localforage.getItem(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
                <span class="hljs-comment">/**
                 * Doesn't have value yet, hash it and finished
                 */</span>
                <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                    cachedInstance.blob().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                        md5HashBody(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                            localforage.setItem(url, hash);
                        });
                    });
                } <span class="hljs-keyword">else</span> {
                    <span class="hljs-comment">/**
                     * Fetch newest hash from server
                     */</span>
                    fetchResponse(config.HASH_ADDRESS, {
                        <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
                        <span class="hljs-attr">headers</span>: {
                            <span class="hljs-string">"Accept"</span>: <span class="hljs-string">"application/json"</span>,
                            <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>
                        },
                        <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({
                            <span class="hljs-attr">url</span>: url
                        })
                    }).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                        response.json().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>{
                            <span class="hljs-comment">/**
                             * Hash is different, fetch file and update caches/database
                             */</span>
                            <span class="hljs-keyword">if</span> (json.hash !== value) {
                                fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                                    <span class="hljs-keyword">if</span> (response &amp;&amp; response.type !== <span class="hljs-string">"error"</span>) {
                                        cacheResponse(url, response);
                                        localforage.setItem(url, json.hash);
                                        postMessages(<span class="hljs-number">0</span>, {<span class="hljs-attr">file</span>: url});
                                    }
                                });
                            }
                        });
                    });
                }
            });
        }).catch(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-comment">/**
             * Cache did not find file
             */</span>

            <span class="hljs-keyword">let</span> cachedInstance;

            fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">networkResponse</span>) </span>{
                <span class="hljs-comment">/**
                 * Check for valid response
                 */</span>
                <span class="hljs-keyword">if</span> (networkResponse &amp;&amp; networkResponse.type !== <span class="hljs-string">"error"</span>) {
                    cachedInstance = networkResponse.clone();
                    cacheResponse(url, networkResponse);

                    localforage.getItem(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
                        <span class="hljs-comment">/**
                         * Doesn't have value yet, hash it and finished
                         */</span>
                        <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                            cachedInstance.blob().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
                                md5HashBody(blob).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                                    localforage.setItem(url, hash);
                                });
                            });
                        } <span class="hljs-keyword">else</span> {
                            <span class="hljs-comment">/**
                             * Fetch newest hash from server
                             */</span>
                            fetchResponse(url, {
                                <span class="hljs-attr">method</span>: <span class="hljs-string">"POST"</span>,
                                <span class="hljs-attr">headers</span>: {
                                    <span class="hljs-string">"Accept"</span>: <span class="hljs-string">"application/json"</span>,
                                    <span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/json"</span>
                                },
                                <span class="hljs-attr">body</span>: <span class="hljs-built_in">JSON</span>.stringify({
                                    <span class="hljs-attr">url</span>: url
                                })
                            }).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                                response.json().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>{
                                    <span class="hljs-comment">/**
                                     * Hash is different, fetch file and update caches/database
                                     */</span>
                                    <span class="hljs-keyword">if</span> (json.hash !== value) {
                                        fetchResponse(url).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                                            <span class="hljs-keyword">if</span> (response &amp;&amp; response.type !== <span class="hljs-string">"error"</span>) {
                                                cacheResponse(url, response);
                                                localforage.setItem(url, json.hash);
                                                postMessages(<span class="hljs-number">0</span>, {<span class="hljs-attr">file</span>: url});
                                            }
                                        });
                                    }
                                });
                            });
                        }
                    });
                }
            });
        });
    })(url);
};

<span class="hljs-comment">/**
 * Responds to an install event received.
 * Since install happens after page load, it is important not to be asyncroneous.
 * @param event
 */</span>
<span class="hljs-keyword">const</span> installEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    event.waitUntil(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
        <span class="hljs-comment">/**
         * Download settings first...
         */</span>
        <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"sw_config.json"</span>).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jsonConfig</span>) </span>{
            <span class="hljs-keyword">await</span> jsonConfig.json().then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>{
                config = merge(<span class="hljs-keyword">new</span> Config(), json.config);
            });
        });
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Installed Service Worker v"</span> + config.VERSION);
        <span class="hljs-keyword">if</span> (config.developer) {
            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Deleting Caches..."</span>);
        }
        <span class="hljs-comment">/**
         * Delete all caches as safety measure
         */</span>
        <span class="hljs-keyword">await</span> caches.keys().then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">keys</span>) </span>{
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
                <span class="hljs-keyword">await</span> caches.delete(keys[i]);
            }
        }).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (config.developer) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Precaching..."</span>);
            }
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; config.PRE_CACHE.length; i++) {
                <span class="hljs-comment">/**
                 * Add all precache files
                 */</span>
                fetchResponse(config.PRE_CACHE[i]).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                    cacheResponse(config.PRE_CACHE[i], response);
                });
            }
        }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
            <span class="hljs-keyword">if</span> (config.developer) {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Done!"</span>);
            }
            self.skipWaiting();
        });
    }());
};

<span class="hljs-comment">/**
 * This is called every time the page is loaded. Therefore, we want to keep it lightweight
 * @param event
 */</span>
<span class="hljs-keyword">const</span> activateEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-comment">/**
     * Check for config updates
     */</span>
    fetch(<span class="hljs-string">"sw_config.json"</span>).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">jsonConfig</span>) </span>{
        <span class="hljs-keyword">let</span> clone = jsonConfig.clone();

        jsonConfig.blob().then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">blob</span>) </span>{
            md5HashBody(blob).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hash</span>) </span>{
                localforage.getItem(<span class="hljs-string">"sw_config.json"</span>).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>{
                    <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) {
                        localforage.setItem(<span class="hljs-string">"sw_config.json"</span>, hash);
                    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (value !== hash) {
                        <span class="hljs-keyword">if</span> (config.developer) {
                            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Received Config Update!"</span>);
                        }
                        <span class="hljs-keyword">await</span> clone.json().then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">json</span>) </span>{
                            config = merge(<span class="hljs-keyword">new</span> Config(), json.config);
                        });
                        localforage.setItem(<span class="hljs-string">"sw_config.json"</span>, hash);
                        <span class="hljs-comment">/**
                         * Delete all caches as safety measure
                         */</span>
                        <span class="hljs-keyword">await</span> caches.keys().then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">keys</span>) </span>{
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) {
                                <span class="hljs-keyword">await</span> caches.delete(keys[i]);
                            }
                        }).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (config.developer) {
                                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Precaching..."</span>);
                            }
                            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; config.PRE_CACHE.length; i++) {
                                <span class="hljs-comment">/**
                                 * Add all precache files
                                 */</span>
                                fetchResponse(config.PRE_CACHE[i]).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                                    cacheResponse(config.PRE_CACHE[i], response);
                                });
                            }
                        }).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
                            <span class="hljs-keyword">if</span> (config.developer) {
                                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Done!"</span>);
                            }
                            postMessages(<span class="hljs-number">1</span>, {});
                        });
                    }
                });
            });
        });
    });
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"[ServiceWorker] Active and Ready!"</span>);
};

<span class="hljs-keyword">let</span> checkUpdateTimeout = <span class="hljs-literal">null</span>;
<span class="hljs-comment">/**
 * Whether it is currently updating. There may sometimes be multiple times this function is called,
 * so this should prevent weird behaviour
 * @type {boolean}
 */</span>
<span class="hljs-keyword">let</span> isUpdating = <span class="hljs-literal">false</span>;

<span class="hljs-comment">/**
 * Checks for updates
 */</span>
<span class="hljs-keyword">const</span> checkUpdate = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">if</span> (config.UPDATE_STRATEGY !== <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">if</span> (!isUpdating) {
            isUpdating = <span class="hljs-literal">true</span>;
            <span class="hljs-keyword">if</span> (updateable.length &gt; <span class="hljs-number">0</span>) {
                <span class="hljs-keyword">let</span> url = updateable[<span class="hljs-number">0</span>];

                updateable.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);
                canBeUpdated(url).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>{
                    <span class="hljs-keyword">if</span> (result) {
                        callbacks[config.UPDATE_CALLBACKS[config.UPDATE_STRATEGY]](url);
                    }
                });
            }
            isUpdating = <span class="hljs-literal">false</span>;
        }
    }
    checkUpdateTimeout = setTimeout(checkUpdate, <span class="hljs-number">500</span>);
};

<span class="hljs-comment">/**
 * Responds to a fetch event received
 * @param event
 */</span>
<span class="hljs-keyword">const</span> fetchEvent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>{
    <span class="hljs-comment">/**
     * Delay update interval by 500ms to handle request
     */</span>
    <span class="hljs-keyword">if</span> (checkUpdateTimeout !== <span class="hljs-literal">null</span>) {
        clearTimeout(checkUpdateTimeout);
        checkUpdateTimeout = setTimeout(checkUpdate, <span class="hljs-number">500</span>);
    }
    event.respondWith(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>eslint-disable-next-line no-debugger</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (config.FETCH_CALLBACKS.length &gt; <span class="hljs-number">0</span> &amp;&amp; config.FETCH_CALLBACKS[event.request.method]) {
            <span class="hljs-keyword">return</span> callbacks[config.FETCH_CALLBACKS[event.request.method]](event).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newEvent</span>) </span>{
                <span class="hljs-keyword">return</span> callbacks[config.STRATEGY_CALLBACKS[config.STRATEGY]](newEvent).then(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>{
                    <span class="hljs-keyword">return</span> response;
                });
            });
        }
        <span class="hljs-keyword">return</span> callbacks[config.STRATEGY_CALLBACKS[config.STRATEGY]](event);
    }());
};

self.addEventListener(<span class="hljs-string">"install"</span>, installEvent);

self.addEventListener(<span class="hljs-string">"fetch"</span>, fetchEvent);

self.addEventListener(<span class="hljs-string">"activate"</span>, activateEvent);

self.onmessage = <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">message</span>) </span>{
    <span class="hljs-keyword">let</span> data = message.data;

    <span class="hljs-keyword">if</span> (data.type === <span class="hljs-number">2</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>eslint-disable-next-line no-new-func</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">let</span> functions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(data.method);

        callbacks[data.name] = functions;
        <span class="hljs-keyword">if</span> (data.callback === <span class="hljs-string">"STRATEGY"</span>) {
            config.STRATEGY_CALLBACKS[<span class="hljs-built_in">Object</span>.keys(config.STRATEGY_CALLBACKS).length] = data.name;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.callback === <span class="hljs-string">"FETCH"</span>) {
            config.FETCH_CALLBACKS[data.fetchMethod] = data.name;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.callback === <span class="hljs-string">"UPDATE"</span>) {
            config.UPDATE_CALLBACKS[<span class="hljs-built_in">Object</span>.keys(config.UPDATE_CALLBACKS).length] = data.name;
        }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (data.type === <span class="hljs-number">3</span>) {
        config[data.field] = data.value;
    }
};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
